#include "hal_data.h"
#include <stdarg.h>
#include <stdio.h>

#include "kwc.h"
#include "sample.h"
#include "debug_print.h"      // 调试打印函数声明
// #include "test_sounds/yes.h" // 测试用音频数据
#include "sys.h"

#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
    {
        .semaphore_num = 0};
#endif

/*******************************************************************************************************************/ /**
                                                                                                                       * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
                                                                                                                       * is called by main() when no RTOS is used.
                                                                                                                       **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    SystickInit();

    // Initialize UART7 for debugging
    g_uart7.p_api->open(g_uart7.p_ctrl, g_uart7.p_cfg);
    print("Hello world\r\n");

    R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);

    // 开启外部按键中断并使能
    g_external_irq6.p_api->open(g_external_irq6.p_ctrl, g_external_irq6.p_cfg);
    g_external_irq6.p_api->enable(g_external_irq6.p_ctrl);

    // 初始化KWS
    kws_init();

    // 初始化采样模块
    sample_init();

    // 直接测试保存的音频，见/test_sounds/
    // kws_preprocess(test_audio_array, 16000, 16000);
    // kws_test();

    while (1)
    {
        sample_start();         // 启动采样模块
        kws_preprocess_pcm();   // 预处理1s PCM数据
        kws();                  // 执行KWS
    }

    /* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while (FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable()
{
}
FSP_CPP_FOOTER

#endif

volatile uint32_t uwPressTick = 0;
void ex_irq6_callback(external_irq_callback_args_t *p_args)
{
    if (p_args->channel == 6) // 按键的GPIO的ICU通道是6
    {
        uwPressTick = HAL_GetTick() + 100;
    }
}

void key_process_jitter(uint32_t tick)
{
    if (tick == uwPressTick)
    {
        uwPressTick = 0;
        bsp_io_level_t level = BSP_IO_LEVEL_HIGH;
        g_ioport.p_api->pinRead(g_ioport.p_ctrl, BSP_IO_PORT_00_PIN_00, &level);
        // print("key level: %u!\r\n", level);
        if (level == BSP_IO_LEVEL_LOW)
        {
            print("key pressed!\r\n");
        }
    }
}